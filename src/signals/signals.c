/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   signals.c                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mhaile <mhaile@student.42abudhabi.ae>      +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/12/29 02:06:00 by akanbari          #+#    #+#             */
/*   Updated: 2024/02/04 13:47:54 by mhaile           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../include/minishell.h"

/*SIGINT: (Interrupt): This signal is typically generated
by the terminal driver when the user presses the interrupt
key (often Ctrl+C). It is 
a way to politely ask a program to terminate and is commonly 
used for graceful termination
It is a way to politely ask a program to terminate and
is commonly used for graceful termination. 
Processes can catch this signal and perform cleanup
operations before exiting.
*/
/*
SIGQUIT (Quit): This signal is also generated by the terminal
driver but usually in response to the user pressing the 
quit key (often Ctrl+\) or (Ctrl \),It is similar to SIGINT 
but is often used when the user wants to terminate a program 
and also generate a core dump for debugging purposes. 
It can be seen as a more forceful way of terminating a 
process compared to SIGINT.
*/

/*
SIG KILL (KILL): this signal is generated when you click ctrl + d,
and it represents the end of file and you have to handle it in main,
when you do not get any input promp from the readline function.
if there is an input and press ctrl + d it will delet letters from the input
*/

void	signal_handler_herdoc(int signum)
{
	int	fd;
	int	child_pid;

	g_exit_status = OFF_HERE_DOC;
	if (signum == SIGINT)
	{
		ft_printf("\n");
		fd = open("child_pid.tmp", O_RDONLY);
		if (fd < 0)
		{
			perror("open");
			exit(1);
		}
		if (read(fd, &child_pid, sizeof(int)) < 0)
		{
			perror("read");
			exit(1);
		}
		close(fd);
		kill(child_pid, SIGKILL);
		rl_replace_line("\n", 0);
		rl_redisplay();
		rl_on_new_line();
	}
}

//set the initial signal handlers when there is no commands and bash si empty
void	signal_handler_input(int signum)
{
	if (signum == SIGQUIT)
	{
		ft_printf_fd(STDERR_FILENO, "Quit: %d\n", SIGQUIT);
		g_exit_status = 131;
		rl_replace_line("", 0);
		rl_on_new_line();
	}
	else if (signum == SIGINT)
	{
		g_exit_status = 130;
		ft_printf_fd(STDERR_FILENO, "\n");
		rl_replace_line("", 0);
		rl_on_new_line();
	}
}

//it will be set inside the chile
void	set_signals_exec(void)
{
	signal(SIGINT, signal_handler_input);
	signal(SIGQUIT, signal_handler_input);
}

void	set_signal_handler_heredoc(t_minishell *shell)
{
	(void)shell;
	if (g_exit_status == IN_HERE_DOC)
	{
		signal(SIGINT, signal_handler_herdoc);
		signal(SIGQUIT, SIG_IGN);
	}
}
